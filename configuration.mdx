---
title: "Configuration"
description: "Configure NativeBridge for optimal performance and security"
---

## Basic Configuration

Configure NativeBridge with options that suit your application's needs:

```javascript
import { NativeBridge } from '@nativebridge/core';

const bridge = new NativeBridge({
  // Enable debug mode for development
  debug: process.env.NODE_ENV === 'development',

  // Set timeout for native calls (milliseconds)
  timeout: 5000,

  // Enable automatic retry on failure
  retry: {
    enabled: true,
    maxAttempts: 3,
    delay: 1000
  },

  // Configure message queue
  queue: {
    maxSize: 100,
    flushInterval: 100
  },

  // Platform-specific settings
  platforms: {
    ios: {
      webViewType: 'WKWebView'
    },
    android: {
      hardwareAcceleration: true
    }
  }
});
```

## Advanced Options

### Performance Optimization

```javascript
const bridge = new NativeBridge({
  performance: {
    // Batch multiple calls into single native invocation
    batching: {
      enabled: true,
      maxBatchSize: 10,
      batchTimeout: 50
    },

    // Cache native method results
    caching: {
      enabled: true,
      ttl: 60000, // 1 minute
      maxSize: 100
    },

    // Lazy load modules
    lazyLoading: true
  }
});
```

### Security Configuration

```javascript
const bridge = new NativeBridge({
  security: {
    // Validate all incoming messages
    validateMessages: true,

    // Whitelist allowed native modules
    allowedModules: ['Device', 'Storage', 'Network'],

    // Enable message encryption
    encryption: {
      enabled: true,
      algorithm: 'AES-256-GCM'
    },

    // Content Security Policy
    csp: {
      enabled: true,
      policy: "default-src 'self'; script-src 'self' 'unsafe-inline'"
    }
  }
});
```

### Error Handling

```javascript
const bridge = new NativeBridge({
  errorHandling: {
    // Global error handler
    onError: (error) => {
      console.error('Bridge error:', error);
      // Send to analytics
      analytics.track('bridge_error', {
        message: error.message,
        code: error.code
      });
    },

    // Fallback for unsupported methods
    fallback: {
      enabled: true,
      handler: (method, params) => {
        console.warn(`Method ${method} not supported, using fallback`);
        return Promise.resolve(null);
      }
    },

    // Error recovery
    recovery: {
      autoReconnect: true,
      reconnectDelay: 1000,
      maxReconnectAttempts: 5
    }
  }
});
```

## Platform-Specific Configuration

### iOS Configuration

<Tabs>
  <Tab title="Swift">
    ```swift Info.plist
    <key>NSAppTransportSecurity</key>
    <dict>
        <key>NSAllowsArbitraryLoads</key>
        <false/>
    </dict>

    <key>NativeBridge</key>
    <dict>
        <key>EnableDebugMode</key>
        <false/>
        <key>AllowedOrigins</key>
        <array>
            <string>https://myapp.com</string>
        </array>
    </dict>
    ```

    ```swift AppDelegate.swift
    import NativeBridge

    func application(_ application: UIApplication,
                    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {

        // Configure NativeBridge
        let config = NativeBridgeConfig()
        config.debugMode = false
        config.logLevel = .warning
        config.messageTimeout = 5.0

        NativeBridge.shared.configure(with: config)

        return true
    }
    ```
  </Tab>
</Tabs>

### Android Configuration

<Tabs>
  <Tab title="Kotlin">
    ```xml AndroidManifest.xml
    <application>
        <meta-data
            android:name="com.nativebridge.DEBUG_MODE"
            android:value="false" />
        <meta-data
            android:name="com.nativebridge.ALLOWED_ORIGINS"
            android:value="https://myapp.com" />
    </application>
    ```

    ```kotlin Application.kt
    import com.nativebridge.NativeBridge
    import com.nativebridge.NativeBridgeConfig

    class MyApplication : Application() {
        override fun onCreate() {
            super.onCreate()

            // Configure NativeBridge
            val config = NativeBridgeConfig.Builder()
                .setDebugMode(BuildConfig.DEBUG)
                .setLogLevel(LogLevel.WARNING)
                .setMessageTimeout(5000)
                .build()

            NativeBridge.configure(config)
        }
    }
    ```
  </Tab>
</Tabs>

## Environment-Based Configuration

### Development vs Production

```javascript
const isDevelopment = process.env.NODE_ENV === 'development';

const config = {
  debug: isDevelopment,

  logging: {
    enabled: isDevelopment,
    level: isDevelopment ? 'verbose' : 'error',
    remoteLogging: !isDevelopment
  },

  performance: {
    monitoring: !isDevelopment,
    reporting: {
      enabled: !isDevelopment,
      endpoint: 'https://analytics.myapp.com/bridge'
    }
  },

  security: {
    validateMessages: !isDevelopment,
    encryption: {
      enabled: !isDevelopment
    }
  }
};

const bridge = new NativeBridge(config);
```

## Module Registration

### JavaScript Side

```javascript
// Register custom modules
bridge.registerModule('CustomAuth', {
  login: async (credentials) => {
    // Custom implementation
  },
  logout: async () => {
    // Custom implementation
  }
});

// Configure module-specific settings
bridge.configureModule('Storage', {
  encryptionKey: 'your-encryption-key',
  maxStorageSize: 10 * 1024 * 1024 // 10MB
});
```

### Native Side

<Tabs>
  <Tab title="iOS">
    ```swift
    class CustomAuthModule: NativeBridgeModule {
        override func configure() {
            self.timeout = 10.0
            self.requiresMainThread = true
            self.cacheable = false
        }
    }
    ```
  </Tab>
  <Tab title="Android">
    ```kotlin
    class CustomAuthModule : NativeBridgeModule() {
        override fun configure() {
            timeout = 10000
            requiresMainThread = true
            cacheable = false
        }
    }
    ```
  </Tab>
</Tabs>

## Testing Configuration

```javascript
// Test configuration
const testBridge = new NativeBridge({
  mock: true,
  mockModules: {
    Device: {
      getInfo: () => Promise.resolve({
        model: 'Test Device',
        platform: 'test'
      })
    }
  }
});

// Use in tests
describe('NativeBridge Tests', () => {
  it('should mock native calls', async () => {
    const info = await testBridge.execute('Device.getInfo');
    expect(info.platform).toBe('test');
  });
});
```

## Configuration Validation

```javascript
// Validate configuration on startup
bridge.validateConfig().then(result => {
  if (!result.valid) {
    console.error('Invalid configuration:', result.errors);
    // Handle invalid configuration
  }
});

// Listen for configuration changes
bridge.onConfigChange((newConfig) => {
  console.log('Configuration updated:', newConfig);
});
```

## Best Practices

<AccordionGroup>
  <Accordion icon="shield" title="Security Best Practices">
    - Always validate messages in production
    - Use encryption for sensitive data
    - Implement proper authentication
    - Whitelist allowed modules and methods
    - Regular security audits
  </Accordion>

  <Accordion icon="rocket" title="Performance Best Practices">
    - Enable batching for multiple calls
    - Use caching for frequently accessed data
    - Implement lazy loading for large modules
    - Monitor bridge performance metrics
    - Optimize message payload size
  </Accordion>

  <Accordion icon="bug" title="Debugging Best Practices">
    - Use debug mode during development
    - Implement comprehensive logging
    - Track error rates and patterns
    - Use remote logging in production
    - Set up alerts for critical errors
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Core Concepts"
    icon="book"
    href="/concepts/bridge-interface"
  >
    Understand how NativeBridge works
  </Card>
  <Card
    title="API Reference"
    icon="code"
    href="/api/javascript-api"
  >
    Explore the complete API
  </Card>
</CardGroup>